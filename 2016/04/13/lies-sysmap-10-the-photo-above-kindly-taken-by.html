<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>lies sysmap 10 the photo above kindly taken by | Dario Sanfilippo</title>
<meta name="generator" content="Jekyll v4.3.2">
<meta property="og:title" content="lies sysmap 10 the photo above kindly taken by">
<meta property="og:locale" content="en_US">
<meta name="description" content="&lt;h2&gt;LIES (sysmap) 1.0&lt;/h2&gt;&lt;p&gt;The photo above (kindly taken by Athena Zhu) is from the premier of the LIES (sysmap) 1.0 project, performed at the Edinburgh College of Art on the 28th of March 2016.&lt;/p&gt;&lt;p&gt;This project builds on my previous performance LIES (topology/nodes) 2.0, although there are some substantial differences which make them two independent works.&lt;/p&gt;&lt;p&gt;The first thing to mention is that, in the new project, some of the DSP techniques in LIES (t/n) 2.0 have been replaced with new ones, whereas the others are of the same type but have been modified and improved. For example, two of the new DSP units are based on pulse-width modulation and filter modulation, the latter being a simple yet effective process where the type (high-pass or low-pass) of a filter and its cutoff changes according to the input signal. Granulators and samplers have been modified and are now implementing variable buffer size and windowing functions, and nested FM modules have a variable nonlinear transfer function. Furthermore, each DSP unit consists of up to eight cascaded subunits, and they are thus capable of generating different streams for multi-channel setups.&lt;/p&gt;&lt;p&gt;In general, another fundamental difference is that the DSP algorithms have been designed so that all their parameters operate at sample-rate: the system is now fully time-varying and every state variables of each subunit is dependent on the incoming signal.&lt;/p&gt;&lt;p&gt;Lastly, and most importantly, this project implements the idea of systemic mapping, which essentially consists in establishing positive and negative feedback relationships between the parameters of each DSP module. This idea is realised by using a one-to-many mapping strategy: a [0;1] range fader, which I control during the performance, interconnects the parameters in the DSP units based on their characteristics so that different state variables can be explored while keeping the same kind of relationships between the parameters.&lt;/p&gt;&lt;p&gt;One of the focus of my work is to implement autonomous systems with complex behaviours. A necessary aspect of achieving autonomy in feedback systems is that of self-oscillation. Such a condition is dependent on two main factors, among others: the amount of energy that the processes allow to recirculate in order to establish a self-sustaining state (given that the feedback coefficients are greater than one); the spectral content of that energy, namely whether it is located in the same areas of the spectrum as those of the poles/resonances of the system (at that specific time). Particularly in feedback systems, these two factors are strictly interrelated and basically all DSP parameters can affect both of them, so it is possible to focus on either of the two to establish the counterbalancing or imbalancing mechanisms among pairs of variables. Intuitively, the criterion for the first factor might be that the higher the amount of energy, the higher the chances of self-oscillation. For the second factor, things are less straightforward considering that the system is nonlinear and time-varying, so it is not always easy to know the exact position of the poles, although we can consider that a wider spectral content would result in higher chances for the system to resonate and self-oscillate. Besides, this criterion would also be consistent with von Foerster’s order-from-noise principle, or Prigogine’s order-out-of-chaos principle, for which non-periodic and large fluctuations, as in rich spectra, can trigger self-organisation more easily. It is important to note that a self-oscillating feedback system needs to be stable. In some cases, power-preservation matrixes are used for such a purpose. I currently have not implemented that technique, although I am quite happy with the results achieved using look-a-head limiters.&lt;/p&gt;&lt;p&gt;Now, to give a practical example of what a counterbalancing or imbalancing mechanism could be with regard to the energy amount or spectral content, let’s consider two parameters in a granulator: grain density and grain size. Concerning the energy amount, density and size are directly proportional to the energy flowing in the system. Concerning the spectral content, density is directly proportional to the richness of the spectrum, whereas size is inversely proportional – the time-bandwidth inverse proportion dates back to 1947 with Gabor’s seminal paper on “acoustical quanta.” Thus, for the first case, counterbalancing translates into having parameters that move towards opposite directions, while for the second case it corresponds to the parameters moving towards the same direction. From this, it is clear that, in some cases, some inconsistencies may arise as, for example, it would not be possible to have a counterbalancing behaviour for both time (energy per unit time) and spectral content. This, though, is not necessarily a problem, as having opposite relationships in a pair of variables with regard to the two domains could be the desired effect, so it would be a matter of keeping track of these restraints in order to have an overall configuration which satisfies the desired effects.&lt;/p&gt;&lt;p&gt;Empirically, my attempt for the performance at ECA was to have roughly an equal number of positive and negative feedback relationships in each DSP unit. This way, the interplay between these relationships should keep the system on the edges of its state transitions, which, in turn, should enhance variety and complexity. A more deterministic approach for connecting the parameters and have a roughly equal number of the two types of relationships could be the following. Assuming that a DSP unit has the parameters A, B, C, D, E, F, G, if we base the connections on only one of the two main factors determining self-oscillation (energy amount or spectral content), we can apply the counterbalancing relationship among successive pairs: A-B, B-C, …, F-G. This way, the relationship which started at A-B will be flipping from negative to positive each time that the function is applied, and, relative to each parameter, half of the remaining parameters will have a negative feedback relationship, whereas the remaining half will have a positive one.&lt;/p&gt;&lt;p&gt;Finally, a further improvement of this idea might be that of having a bidimensional control interface, for example the x-y coordinates of the mouse cursor rather than a single fader, so that the time-domain-based relationships could be mapped on one axis, while the frequency-domain-based ones could be mapped on the other, creating a weighted interpolation between the two when exploring the bidimensional area.&lt;/p&gt;">
<meta property="og:description" content="&lt;h2&gt;LIES (sysmap) 1.0&lt;/h2&gt;&lt;p&gt;The photo above (kindly taken by Athena Zhu) is from the premier of the LIES (sysmap) 1.0 project, performed at the Edinburgh College of Art on the 28th of March 2016.&lt;/p&gt;&lt;p&gt;This project builds on my previous performance LIES (topology/nodes) 2.0, although there are some substantial differences which make them two independent works.&lt;/p&gt;&lt;p&gt;The first thing to mention is that, in the new project, some of the DSP techniques in LIES (t/n) 2.0 have been replaced with new ones, whereas the others are of the same type but have been modified and improved. For example, two of the new DSP units are based on pulse-width modulation and filter modulation, the latter being a simple yet effective process where the type (high-pass or low-pass) of a filter and its cutoff changes according to the input signal. Granulators and samplers have been modified and are now implementing variable buffer size and windowing functions, and nested FM modules have a variable nonlinear transfer function. Furthermore, each DSP unit consists of up to eight cascaded subunits, and they are thus capable of generating different streams for multi-channel setups.&lt;/p&gt;&lt;p&gt;In general, another fundamental difference is that the DSP algorithms have been designed so that all their parameters operate at sample-rate: the system is now fully time-varying and every state variables of each subunit is dependent on the incoming signal.&lt;/p&gt;&lt;p&gt;Lastly, and most importantly, this project implements the idea of systemic mapping, which essentially consists in establishing positive and negative feedback relationships between the parameters of each DSP module. This idea is realised by using a one-to-many mapping strategy: a [0;1] range fader, which I control during the performance, interconnects the parameters in the DSP units based on their characteristics so that different state variables can be explored while keeping the same kind of relationships between the parameters.&lt;/p&gt;&lt;p&gt;One of the focus of my work is to implement autonomous systems with complex behaviours. A necessary aspect of achieving autonomy in feedback systems is that of self-oscillation. Such a condition is dependent on two main factors, among others: the amount of energy that the processes allow to recirculate in order to establish a self-sustaining state (given that the feedback coefficients are greater than one); the spectral content of that energy, namely whether it is located in the same areas of the spectrum as those of the poles/resonances of the system (at that specific time). Particularly in feedback systems, these two factors are strictly interrelated and basically all DSP parameters can affect both of them, so it is possible to focus on either of the two to establish the counterbalancing or imbalancing mechanisms among pairs of variables. Intuitively, the criterion for the first factor might be that the higher the amount of energy, the higher the chances of self-oscillation. For the second factor, things are less straightforward considering that the system is nonlinear and time-varying, so it is not always easy to know the exact position of the poles, although we can consider that a wider spectral content would result in higher chances for the system to resonate and self-oscillate. Besides, this criterion would also be consistent with von Foerster’s order-from-noise principle, or Prigogine’s order-out-of-chaos principle, for which non-periodic and large fluctuations, as in rich spectra, can trigger self-organisation more easily. It is important to note that a self-oscillating feedback system needs to be stable. In some cases, power-preservation matrixes are used for such a purpose. I currently have not implemented that technique, although I am quite happy with the results achieved using look-a-head limiters.&lt;/p&gt;&lt;p&gt;Now, to give a practical example of what a counterbalancing or imbalancing mechanism could be with regard to the energy amount or spectral content, let’s consider two parameters in a granulator: grain density and grain size. Concerning the energy amount, density and size are directly proportional to the energy flowing in the system. Concerning the spectral content, density is directly proportional to the richness of the spectrum, whereas size is inversely proportional – the time-bandwidth inverse proportion dates back to 1947 with Gabor’s seminal paper on “acoustical quanta.” Thus, for the first case, counterbalancing translates into having parameters that move towards opposite directions, while for the second case it corresponds to the parameters moving towards the same direction. From this, it is clear that, in some cases, some inconsistencies may arise as, for example, it would not be possible to have a counterbalancing behaviour for both time (energy per unit time) and spectral content. This, though, is not necessarily a problem, as having opposite relationships in a pair of variables with regard to the two domains could be the desired effect, so it would be a matter of keeping track of these restraints in order to have an overall configuration which satisfies the desired effects.&lt;/p&gt;&lt;p&gt;Empirically, my attempt for the performance at ECA was to have roughly an equal number of positive and negative feedback relationships in each DSP unit. This way, the interplay between these relationships should keep the system on the edges of its state transitions, which, in turn, should enhance variety and complexity. A more deterministic approach for connecting the parameters and have a roughly equal number of the two types of relationships could be the following. Assuming that a DSP unit has the parameters A, B, C, D, E, F, G, if we base the connections on only one of the two main factors determining self-oscillation (energy amount or spectral content), we can apply the counterbalancing relationship among successive pairs: A-B, B-C, …, F-G. This way, the relationship which started at A-B will be flipping from negative to positive each time that the function is applied, and, relative to each parameter, half of the remaining parameters will have a negative feedback relationship, whereas the remaining half will have a positive one.&lt;/p&gt;&lt;p&gt;Finally, a further improvement of this idea might be that of having a bidimensional control interface, for example the x-y coordinates of the mouse cursor rather than a single fader, so that the time-domain-based relationships could be mapped on one axis, while the frequency-domain-based ones could be mapped on the other, creating a weighted interpolation between the two when exploring the bidimensional area.&lt;/p&gt;">
<link rel="canonical" href="/2016/04/13/lies-sysmap-10-the-photo-above-kindly-taken-by.html">
<meta property="og:url" content="/2016/04/13/lies-sysmap-10-the-photo-above-kindly-taken-by.html">
<meta property="og:site_name" content="Dario Sanfilippo">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2016-04-13T11:07:09+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="lies sysmap 10 the photo above kindly taken by">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2016-04-13T11:07:09+00:00","datePublished":"2016-04-13T11:07:09+00:00","description":"&lt;h2&gt;LIES (sysmap) 1.0&lt;/h2&gt;&lt;p&gt;The photo above (kindly taken by Athena Zhu) is from the premier of the LIES (sysmap) 1.0 project, performed at the Edinburgh College of Art on the 28th of March 2016.&lt;/p&gt;&lt;p&gt;This project builds on my previous performance LIES (topology/nodes) 2.0, although there are some substantial differences which make them two independent works.&lt;/p&gt;&lt;p&gt;The first thing to mention is that, in the new project, some of the DSP techniques in LIES (t/n) 2.0 have been replaced with new ones, whereas the others are of the same type but have been modified and improved. For example, two of the new DSP units are based on pulse-width modulation and filter modulation, the latter being a simple yet effective process where the type (high-pass or low-pass) of a filter and its cutoff changes according to the input signal. Granulators and samplers have been modified and are now implementing variable buffer size and windowing functions, and nested FM modules have a variable nonlinear transfer function. Furthermore, each DSP unit consists of up to eight cascaded subunits, and they are thus capable of generating different streams for multi-channel setups.&lt;/p&gt;&lt;p&gt;In general, another fundamental difference is that the DSP algorithms have been designed so that all their parameters operate at sample-rate: the system is now fully time-varying and every state variables of each subunit is dependent on the incoming signal.&lt;/p&gt;&lt;p&gt;Lastly, and most importantly, this project implements the idea of systemic mapping, which essentially consists in establishing positive and negative feedback relationships between the parameters of each DSP module. This idea is realised by using a one-to-many mapping strategy: a [0;1] range fader, which I control during the performance, interconnects the parameters in the DSP units based on their characteristics so that different state variables can be explored while keeping the same kind of relationships between the parameters.&lt;/p&gt;&lt;p&gt;One of the focus of my work is to implement autonomous systems with complex behaviours. A necessary aspect of achieving autonomy in feedback systems is that of self-oscillation. Such a condition is dependent on two main factors, among others: the amount of energy that the processes allow to recirculate in order to establish a self-sustaining state (given that the feedback coefficients are greater than one); the spectral content of that energy, namely whether it is located in the same areas of the spectrum as those of the poles/resonances of the system (at that specific time). Particularly in feedback systems, these two factors are strictly interrelated and basically all DSP parameters can affect both of them, so it is possible to focus on either of the two to establish the counterbalancing or imbalancing mechanisms among pairs of variables. Intuitively, the criterion for the first factor might be that the higher the amount of energy, the higher the chances of self-oscillation. For the second factor, things are less straightforward considering that the system is nonlinear and time-varying, so it is not always easy to know the exact position of the poles, although we can consider that a wider spectral content would result in higher chances for the system to resonate and self-oscillate. Besides, this criterion would also be consistent with von Foerster’s order-from-noise principle, or Prigogine’s order-out-of-chaos principle, for which non-periodic and large fluctuations, as in rich spectra, can trigger self-organisation more easily. It is important to note that a self-oscillating feedback system needs to be stable. In some cases, power-preservation matrixes are used for such a purpose. I currently have not implemented that technique, although I am quite happy with the results achieved using look-a-head limiters.&lt;/p&gt;&lt;p&gt;Now, to give a practical example of what a counterbalancing or imbalancing mechanism could be with regard to the energy amount or spectral content, let’s consider two parameters in a granulator: grain density and grain size. Concerning the energy amount, density and size are directly proportional to the energy flowing in the system. Concerning the spectral content, density is directly proportional to the richness of the spectrum, whereas size is inversely proportional – the time-bandwidth inverse proportion dates back to 1947 with Gabor’s seminal paper on “acoustical quanta.” Thus, for the first case, counterbalancing translates into having parameters that move towards opposite directions, while for the second case it corresponds to the parameters moving towards the same direction. From this, it is clear that, in some cases, some inconsistencies may arise as, for example, it would not be possible to have a counterbalancing behaviour for both time (energy per unit time) and spectral content. This, though, is not necessarily a problem, as having opposite relationships in a pair of variables with regard to the two domains could be the desired effect, so it would be a matter of keeping track of these restraints in order to have an overall configuration which satisfies the desired effects.&lt;/p&gt;&lt;p&gt;Empirically, my attempt for the performance at ECA was to have roughly an equal number of positive and negative feedback relationships in each DSP unit. This way, the interplay between these relationships should keep the system on the edges of its state transitions, which, in turn, should enhance variety and complexity. A more deterministic approach for connecting the parameters and have a roughly equal number of the two types of relationships could be the following. Assuming that a DSP unit has the parameters A, B, C, D, E, F, G, if we base the connections on only one of the two main factors determining self-oscillation (energy amount or spectral content), we can apply the counterbalancing relationship among successive pairs: A-B, B-C, …, F-G. This way, the relationship which started at A-B will be flipping from negative to positive each time that the function is applied, and, relative to each parameter, half of the remaining parameters will have a negative feedback relationship, whereas the remaining half will have a positive one.&lt;/p&gt;&lt;p&gt;Finally, a further improvement of this idea might be that of having a bidimensional control interface, for example the x-y coordinates of the mouse cursor rather than a single fader, so that the time-domain-based relationships could be mapped on one axis, while the frequency-domain-based ones could be mapped on the other, creating a weighted interpolation between the two when exploring the bidimensional area.&lt;/p&gt;","headline":"lies sysmap 10 the photo above kindly taken by","mainEntityOfPage":{"@type":"WebPage","@id":"/2016/04/13/lies-sysmap-10-the-photo-above-kindly-taken-by.html"},"url":"/2016/04/13/lies-sysmap-10-the-photo-above-kindly-taken-by.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="shortcut icon" href="">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/assets/css/main.css">
  <script src="/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Dario Sanfilippo">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/go.min.js"></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightBlock(block);
  }

  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    border-radius: 0 2px;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
</head>
<body>



























































































































<header class="site-header " role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<span class="site-brand"><a class="site-brand-inner" rel="author" href="/">
  <img class="site-favicon" title="Dario Sanfilippo" src="" onerror="this.style.display='none'">
  Dario Sanfilippo
</a>
</span><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">
<a class="page-link" href="/">HOME</a><a class="page-link" href="/about.html">ABOUT</a><a class="page-link" href="/portfolio.html">PORTFOLIO</a><a class="page-link" href="/events.html">EVENTS</a><a class="page-link" href="/publications.html">PUBLICATIONS</a><a class="page-link" href="/cv.html">CV</a>




</div>
        </nav>
</div>
  </div>
</header>

<script>
  function initHeader() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  }
  document.addEventListener('DOMContentLoaded', initHeader);
</script>
















































































































































<script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    hashValue = decodeURIComponent(hashValue);
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = element.offsetTop - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('off' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true
    }
  };
</script>


<img src="https://64.media.tumblr.com/e211601e3dd6b211b36b0e5241ccd07b/tumblr_o50zsuWLT71r0ulxko1_1280.jpg"><br><h2><b>LIES (sysmap) 1.0</b></h2>
<p>The photo above (kindly taken by Athena Zhu) is from the premier of the <i>LIES (sysmap) 1.0</i> project, performed at the Edinburgh College of Art on the 28th of March 2016.</p>
<p>This project builds on my previous performance <i><a href="http://dariosanfilippo.tumblr.com/post/91633993871/new-feedback-system-in-the-past-years-i-have" target="_blank">LIES (topology/nodes) 2.0</a></i>, although there are some substantial differences which make them two independent works.</p>
<p>The first thing to mention is that, in the new project, some of the DSP techniques in <i>LIES (t/n) 2.0</i> have been replaced with new ones, whereas the others are of the same type but have been modified and improved. For example, two of the new DSP units are based on pulse-width modulation and filter modulation, the latter being a simple yet effective process where the type (high-pass or low-pass) of a filter and its cutoff changes according to the input signal. Granulators and samplers have been modified and are now implementing variable buffer size and windowing functions, and nested FM modules have a variable nonlinear transfer function. Furthermore, each DSP unit consists of up to eight cascaded subunits, and they are thus capable of generating different streams for multi-channel setups.</p>
<p>In general, another fundamental difference is that the DSP algorithms have been designed so that all their parameters operate at sample-rate: the system is now fully time-varying and every state variables of each subunit is dependent on the incoming signal.</p>
<p>Lastly, and most importantly, this project implements the idea of <i>systemic mapping</i>, which essentially consists in establishing positive and negative feedback relationships between the parameters of each DSP module. This idea is realised by using a one-to-many mapping strategy: a [0;1] range fader, which I control during the performance, interconnects the parameters in the DSP units based on their characteristics so that different state variables can be explored while keeping the same kind of relationships between the parameters.</p>
<p>One of the focus of my work is to implement autonomous systems with complex behaviours. A necessary aspect of achieving autonomy in feedback systems is that of self-oscillation. Such a condition is dependent on two main factors, among others: the amount of energy that the processes allow to recirculate in order to establish a self-sustaining state (given that the feedback coefficients are greater than one); the spectral content of that energy, namely whether it is located in the same areas of the spectrum as those of the poles/resonances of the system (at that specific time). Particularly in feedback systems, these two factors are strictly interrelated and basically all DSP parameters can affect both of them, so it is possible to focus on either of the two to establish the counterbalancing or imbalancing mechanisms among pairs of variables. Intuitively, the criterion for the first factor might be that the higher the amount of energy, the higher the chances of self-oscillation. For the second factor, things are less straightforward considering that the system is nonlinear and time-varying, so it is not always easy to know the exact position of the poles, although we can consider that a wider spectral content would result in higher chances for the system to resonate and self-oscillate. Besides, this criterion would also be consistent with von Foerster’s order-from-noise principle, or Prigogine’s order-out-of-chaos principle, for which non-periodic and large fluctuations, as in rich spectra, can trigger self-organisation more easily. It is important to note that a self-oscillating feedback system needs to be stable. In some cases, power-preservation matrixes are used for such a purpose. I currently have not implemented that technique, although I am quite happy with the results achieved using look-a-head limiters.</p>
<p>Now, to give a practical example of what a counterbalancing or imbalancing mechanism could be with regard to the energy amount or spectral content, let’s consider two parameters in a granulator: grain density and grain size. Concerning the energy amount, density and size are directly proportional to the energy flowing in the system. Concerning the spectral content, density is directly proportional to the richness of the spectrum, whereas size is inversely proportional – the time-bandwidth inverse proportion dates back to 1947 with Gabor’s seminal paper on “acoustical quanta.” Thus, for the first case, counterbalancing translates into having parameters that move towards opposite directions, while for the second case it corresponds to the parameters moving towards the same direction. From this, it is clear that, in some cases, some inconsistencies may arise as, for example, it would not be possible to have a counterbalancing behaviour for both time (energy per unit time) and spectral content. This, though, is not necessarily a problem, as having opposite relationships in a pair of variables with regard to the two domains could be the desired effect, so it would be a matter of keeping track of these restraints in order to have an overall configuration which satisfies the desired effects.</p>
<p>Empirically, my attempt for the performance at ECA was to have roughly an equal number of positive and negative feedback relationships in each DSP unit. This way, the interplay between these relationships should keep the system on the edges of its state transitions, which, in turn, should enhance variety and complexity. A more deterministic approach for connecting the parameters and have a roughly equal number of the two types of relationships could be the following. Assuming that a DSP unit has the parameters A, B, C, D, E, F, G, if we base the connections on only one of the two main factors determining self-oscillation (energy amount or spectral content), we can apply the counterbalancing relationship among successive pairs: A-B, B-C, …, F-G. This way, the relationship which started at A-B will be flipping from negative to positive each time that the function is applied, and, relative to each parameter, half of the remaining parameters will have a negative feedback relationship, whereas the remaining half will have a positive one.</p>
<p>Finally, a further improvement of this idea might be that of having a bidimensional control interface, for example the x-y coordinates of the mouse cursor rather than a single fader, so that the time-domain-based relationships could be mapped on one axis, while the frequency-domain-based ones could be mapped on the other, creating a weighted interpolation between the two when exploring the bidimensional area.</p>


      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
<!--<div></div>
      <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
      generator." href="http://jekyllrb.com/">Jekyll</a> &amp; <a title="Yat, yet
      another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>.</div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/feed.xml">via RSS</a></div>-->
      <div>
<a href="mailto:sanfilippo.dario@gmail.com">Email</a> | <a href="https://github.com/dariosanfilippo/" target="_blank" rel="“noreferrer" noopener>Github</a> | <a href="https://scholar.google.com/citations?user=eXSEPWEAAAAJ&hl=en" target="_blank" rel="“noreferrer" noopener>Google Scholar</a> | <a href="https://soundcloud.com/dario-sanfilippo" target="_blank" rel="“noreferrer" noopener>SoundCloud</a>
</div>
    </div>
  </div>
</footer>
</body>
</html>
