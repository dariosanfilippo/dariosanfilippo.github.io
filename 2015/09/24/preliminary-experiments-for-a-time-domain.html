<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Preliminary experiments for a time-domain brightness estimator based on negative feedback | Dario Sanfilippo</title>
<meta name="generator" content="Jekyll v4.3.2">
<meta property="og:title" content="Preliminary experiments for a time-domain brightness estimator based on negative feedback">
<meta property="og:locale" content="en_US">
<meta name="description" content="The brightness of a sound is usually linked to the spectral centroid and is commonly obtained through FFT analysis and the calculation of a weighted mean of the magnitude of the frequency components. In order to have an accurate result using this technique a relatively large analysis window is necessary and, in some cases, it might be computationally too expensive and not ideal, especially if the project requires many of these units. Di Scipio has already explored the idea of a brightness estimator in the time-domain in his Ecosistemico Udibile n.2 (Feedback Study), in which he performs the estimation simply by dividing the spectrum into two parts and then calculating the difference between the energy content of the two regions to see if the overall content is more in the low or high frequency range. I am currently on a bus heading to London and since the journey is relatively long, I decided to try out some possibilities with Pure Data as I am planning to use brightness analysis for the next projects. The preliminary results seem to be sort of satisfying. The idea is very simple, and even in this case it is based on dividing the spectrum into two regions, although the splitting point here is variable and is dependent on the resulting energy difference between the two spectra, which is what creates the self-regulating mechanism that performs the estimation. The input signal to be analysed is routed to a low-pass and high-pass filters whose cut-off frequency is linked. The RMS of the output of the two filters is calculated on a window of 1 second, and it is then calculated the energy difference between high and low spectrum. Intuitively, the cut-off frequency which results in a difference of zero is the spectral centroid of that signal, as the energy would be equally spread between the two parts of the spectrum. If the difference is a negative number there is more energy in the low region, if it is positive there is more energy in the high region, and this information can thus be used to shift the cut-off frequency of the filters towards either directions in order to counterbalance the difference. How great the difference is, instead, can be used as information on how much shift it is needed to cancel out the difference in the shortest time possible. This kind of behaviour has been implemented by simply letting the energy difference drive the frequency of a phasor~ object - whose task is to linearly ramp out between 0 and 1 - and then by mapping the output of phasor~ to the entire frequency range to, in turn, set the cut-off frequency of the filters. A negative frequency will shift down, a positive frequency will shift up, and the greater the value of the frequency, the faster the shift will be carried out. This way, the system will find stability (although it will always be oscillating, even if for extremely small values) around a cut-off frequency which results in a zero-difference, indeed representing the centroid and brightness index of the signal. The first issue encountered was the different responsiveness of the system with regard to different signals, namely to signals with different amplitudes. What I thought it could have been a work around was to normalise the RMS values out of the filters by using the RMS value of the input signal as a reference. Basically, the resulting difference is divided (avoiding zeroes) by the RMS of the input signal in order to keep the same range and have the responsiveness dependent on the relative energy difference rather than on the overall energy.  Lastly, the mapping between the phasor~ and the frequency range was chosen as a nonlinear one in order to have an index roughly closer to what the perception is. In conclusion, with further refinements this might be a CPU-less-expensive extractor for brightness information which could be implemented with good results in some contexts, although the system becomes particularly non accurate in case the input signal has for example, and in the worst scenario, two sinusoidal components very far apart, which isn’t anyway something you would easily expect.">
<meta property="og:description" content="The brightness of a sound is usually linked to the spectral centroid and is commonly obtained through FFT analysis and the calculation of a weighted mean of the magnitude of the frequency components. In order to have an accurate result using this technique a relatively large analysis window is necessary and, in some cases, it might be computationally too expensive and not ideal, especially if the project requires many of these units. Di Scipio has already explored the idea of a brightness estimator in the time-domain in his Ecosistemico Udibile n.2 (Feedback Study), in which he performs the estimation simply by dividing the spectrum into two parts and then calculating the difference between the energy content of the two regions to see if the overall content is more in the low or high frequency range. I am currently on a bus heading to London and since the journey is relatively long, I decided to try out some possibilities with Pure Data as I am planning to use brightness analysis for the next projects. The preliminary results seem to be sort of satisfying. The idea is very simple, and even in this case it is based on dividing the spectrum into two regions, although the splitting point here is variable and is dependent on the resulting energy difference between the two spectra, which is what creates the self-regulating mechanism that performs the estimation. The input signal to be analysed is routed to a low-pass and high-pass filters whose cut-off frequency is linked. The RMS of the output of the two filters is calculated on a window of 1 second, and it is then calculated the energy difference between high and low spectrum. Intuitively, the cut-off frequency which results in a difference of zero is the spectral centroid of that signal, as the energy would be equally spread between the two parts of the spectrum. If the difference is a negative number there is more energy in the low region, if it is positive there is more energy in the high region, and this information can thus be used to shift the cut-off frequency of the filters towards either directions in order to counterbalance the difference. How great the difference is, instead, can be used as information on how much shift it is needed to cancel out the difference in the shortest time possible. This kind of behaviour has been implemented by simply letting the energy difference drive the frequency of a phasor~ object - whose task is to linearly ramp out between 0 and 1 - and then by mapping the output of phasor~ to the entire frequency range to, in turn, set the cut-off frequency of the filters. A negative frequency will shift down, a positive frequency will shift up, and the greater the value of the frequency, the faster the shift will be carried out. This way, the system will find stability (although it will always be oscillating, even if for extremely small values) around a cut-off frequency which results in a zero-difference, indeed representing the centroid and brightness index of the signal. The first issue encountered was the different responsiveness of the system with regard to different signals, namely to signals with different amplitudes. What I thought it could have been a work around was to normalise the RMS values out of the filters by using the RMS value of the input signal as a reference. Basically, the resulting difference is divided (avoiding zeroes) by the RMS of the input signal in order to keep the same range and have the responsiveness dependent on the relative energy difference rather than on the overall energy.  Lastly, the mapping between the phasor~ and the frequency range was chosen as a nonlinear one in order to have an index roughly closer to what the perception is. In conclusion, with further refinements this might be a CPU-less-expensive extractor for brightness information which could be implemented with good results in some contexts, although the system becomes particularly non accurate in case the input signal has for example, and in the worst scenario, two sinusoidal components very far apart, which isn’t anyway something you would easily expect.">
<link rel="canonical" href="/2015/09/24/preliminary-experiments-for-a-time-domain.html">
<meta property="og:url" content="/2015/09/24/preliminary-experiments-for-a-time-domain.html">
<meta property="og:site_name" content="Dario Sanfilippo">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2015-09-24T18:12:53+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Preliminary experiments for a time-domain brightness estimator based on negative feedback">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2015-09-24T18:12:53+00:00","datePublished":"2015-09-24T18:12:53+00:00","description":"The brightness of a sound is usually linked to the spectral centroid and is commonly obtained through FFT analysis and the calculation of a weighted mean of the magnitude of the frequency components. In order to have an accurate result using this technique a relatively large analysis window is necessary and, in some cases, it might be computationally too expensive and not ideal, especially if the project requires many of these units. Di Scipio has already explored the idea of a brightness estimator in the time-domain in his Ecosistemico Udibile n.2 (Feedback Study), in which he performs the estimation simply by dividing the spectrum into two parts and then calculating the difference between the energy content of the two regions to see if the overall content is more in the low or high frequency range. I am currently on a bus heading to London and since the journey is relatively long, I decided to try out some possibilities with Pure Data as I am planning to use brightness analysis for the next projects. The preliminary results seem to be sort of satisfying. The idea is very simple, and even in this case it is based on dividing the spectrum into two regions, although the splitting point here is variable and is dependent on the resulting energy difference between the two spectra, which is what creates the self-regulating mechanism that performs the estimation. The input signal to be analysed is routed to a low-pass and high-pass filters whose cut-off frequency is linked. The RMS of the output of the two filters is calculated on a window of 1 second, and it is then calculated the energy difference between high and low spectrum. Intuitively, the cut-off frequency which results in a difference of zero is the spectral centroid of that signal, as the energy would be equally spread between the two parts of the spectrum. If the difference is a negative number there is more energy in the low region, if it is positive there is more energy in the high region, and this information can thus be used to shift the cut-off frequency of the filters towards either directions in order to counterbalance the difference. How great the difference is, instead, can be used as information on how much shift it is needed to cancel out the difference in the shortest time possible. This kind of behaviour has been implemented by simply letting the energy difference drive the frequency of a phasor~ object - whose task is to linearly ramp out between 0 and 1 - and then by mapping the output of phasor~ to the entire frequency range to, in turn, set the cut-off frequency of the filters. A negative frequency will shift down, a positive frequency will shift up, and the greater the value of the frequency, the faster the shift will be carried out. This way, the system will find stability (although it will always be oscillating, even if for extremely small values) around a cut-off frequency which results in a zero-difference, indeed representing the centroid and brightness index of the signal. The first issue encountered was the different responsiveness of the system with regard to different signals, namely to signals with different amplitudes. What I thought it could have been a work around was to normalise the RMS values out of the filters by using the RMS value of the input signal as a reference. Basically, the resulting difference is divided (avoiding zeroes) by the RMS of the input signal in order to keep the same range and have the responsiveness dependent on the relative energy difference rather than on the overall energy.  Lastly, the mapping between the phasor~ and the frequency range was chosen as a nonlinear one in order to have an index roughly closer to what the perception is. In conclusion, with further refinements this might be a CPU-less-expensive extractor for brightness information which could be implemented with good results in some contexts, although the system becomes particularly non accurate in case the input signal has for example, and in the worst scenario, two sinusoidal components very far apart, which isn’t anyway something you would easily expect.","headline":"Preliminary experiments for a time-domain brightness estimator based on negative feedback","mainEntityOfPage":{"@type":"WebPage","@id":"/2015/09/24/preliminary-experiments-for-a-time-domain.html"},"url":"/2015/09/24/preliminary-experiments-for-a-time-domain.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="shortcut icon" href="">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/assets/css/main.css">
  <script src="/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Dario Sanfilippo">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/go.min.js"></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightBlock(block);
  }

  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    border-radius: 0 2px;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
</head>
<body>



























































































































<header class="site-header " role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<span class="site-brand"><a class="site-brand-inner" rel="author" href="/">
  <img class="site-favicon" title="Dario Sanfilippo" src="" onerror="this.style.display='none'">
  Dario Sanfilippo
</a>
</span><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">
<a class="page-link" href="/">HOME</a><a class="page-link" href="/about.html">ABOUT</a><a class="page-link" href="/portfolio.html">PORTFOLIO</a><a class="page-link" href="/events.html">EVENTS</a><a class="page-link" href="/publications.html">PUBLICATIONS</a><a class="page-link" href="/cv.html">CV</a>




</div>
        </nav>
</div>
  </div>
</header>

<script>
  function initHeader() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  }
  document.addEventListener('DOMContentLoaded', initHeader);
</script>
















































































































































<script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    hashValue = decodeURIComponent(hashValue);
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = element.offsetTop - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('off' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true
    }
  };
</script>


<p>The brightness of a sound is usually linked to the spectral centroid and is commonly obtained through FFT analysis and the calculation of a weighted mean of the magnitude of the frequency components. In order to have an accurate result using this technique a relatively large analysis window is necessary and, in some cases, it might be computationally too expensive and not ideal, especially if the project requires many of these units.</p>
<p>Di Scipio has already explored the idea of a brightness estimator in the time-domain in his <i>Ecosistemico Udibile n.2 (Feedback Study), </i>in which he performs the estimation simply by dividing the spectrum into two parts and then calculating the difference between the energy content of the two regions to see if the overall content is more in the low or high frequency range.</p>
<p>I am currently on a bus heading to London and since the journey is relatively long, I decided to try out some possibilities with Pure Data as I am planning to use brightness analysis for the next projects. The preliminary results seem to be sort of satisfying.</p>
<p>The idea is very simple, and even in this case it is based on dividing the spectrum into two regions, although the splitting point here is variable and is dependent on the resulting energy difference between the two spectra, which is what creates the self-regulating mechanism that performs the estimation.</p>
<p>The input signal to be analysed is routed to a low-pass and high-pass filters whose cut-off frequency is linked. The RMS of the output of the two filters is calculated on a window of 1 second, and it is then calculated the energy difference between high and low spectrum. Intuitively, the cut-off frequency which results in a difference of zero is the spectral centroid of that signal, as the energy would be equally spread between the two parts of the spectrum. If the difference is a negative number there is more energy in the low region, if it is positive there is more energy in the high region, and this information can thus be used to shift the cut-off frequency of the filters towards either directions in order to counterbalance the difference. How great the difference is, instead, can be used as information on how much shift it is needed to cancel out the difference in the shortest time possible.</p>
<p>This kind of behaviour has been implemented by simply letting the energy difference drive the frequency of a phasor~ object - whose task is to linearly ramp out between 0 and 1 - and then by mapping the output of phasor~ to the entire frequency range to, in turn, set the cut-off frequency of the filters. A negative frequency will shift down, a positive frequency will shift up, and the greater the value of the frequency, the faster the shift will be carried out. This way, the system will find stability (although it will always be oscillating, even if for extremely small values) around a cut-off frequency which results in a zero-difference, indeed representing the centroid and brightness index of the signal.</p>
<p>The first issue encountered was the different responsiveness of the system with regard to different signals, namely to signals with different amplitudes. What I thought it could have been a work around was to normalise the RMS values out of the filters by using the RMS value of the input signal as a reference. Basically, the resulting difference is divided (avoiding zeroes) by the RMS of the input signal in order to keep the same range and have the responsiveness dependent on the relative energy difference rather than on the overall energy. </p>
<p>Lastly, the mapping between the phasor~ and the frequency range was chosen as a nonlinear one in order to have an index roughly closer to what the perception is.</p>
<p>In conclusion, with further refinements this might be a CPU-less-expensive extractor for brightness information which could be implemented with good results in some contexts, although the system becomes particularly <i>non</i> accurate in case the input signal has for example, and in the worst scenario, two sinusoidal components very far apart, which isn’t anyway something you would easily expect.</p>
<figure data-orig-width="375" data-orig-height="450" class="tmblr-full"><img src="https://64.media.tumblr.com/7eef4ef6638fc39bc9e4edf4f80be80d/tumblr_inline_nv6vr3UoCu1qlphda_540.jpg" alt="image" data-orig-width="375" data-orig-height="450"></figure>


      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
<!--<div></div>
      <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
      generator." href="http://jekyllrb.com/">Jekyll</a> &amp; <a title="Yat, yet
      another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>.</div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/feed.xml">via RSS</a></div>-->
      <div>
<a href="mailto:sanfilippo.dario@gmail.com">Email</a> | <a href="https://github.com/dariosanfilippo/" target="_blank" rel="“noreferrer" noopener>Github</a> | <a href="https://scholar.google.com/citations?user=eXSEPWEAAAAJ&hl=en" target="_blank" rel="“noreferrer" noopener>Google Scholar</a> | <a href="https://soundcloud.com/dario-sanfilippo" target="_blank" rel="“noreferrer" noopener>SoundCloud</a>
</div>
    </div>
  </div>
</footer>
</body>
</html>
